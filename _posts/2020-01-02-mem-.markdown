---
layout: post
title: '[42] mem-(메모리 조작함수)'
date: 2020-01-02 19:20:23 +0900
category: '[42]libft'
---
# mem- (메모리조작함수) _<string.h>

- **ft_memset**

    ### 형식

    memory set 

    ```c
    #include <string.h>

    void* memset(void* ptr, int value, size_t num);
    ```

    메모리 블록을 채운다.ptr 로 시작하는 메모리 주소 부터 num 개의 바이트를 value 값으로 채운다. 이 때, value 는 unsigned char 로 형변환 된다.

    ### **인자**

    `ptr`

    값을 채울 메모리의 시작 주소

    `value`

    채울 값. 인자로는 `int` 로 전달되지만 함수 내부적으로는 `unsigned char` 로 형변환 되어서 사용된다.

    `num`

    `value` 로 채울 바이트 수

    ### **리턴값**

    `ptr` 이 리턴된다.

    ### 주의점 - [링크](https://codingdog.tistory.com/entry/c언어-memset-어떠한-수들만-초기화-가능할까)

    바이트 단위로 초기화 하기 때문에, int형이나 longlong형 배열과 같은 경우 배열에 memset로 0, -1은 넣을 수 있는데, 외의 숫자는 넣을 수 없다. // 0하고 -1로만 초기화 가능하다.

    - 0은 00000000, -1은 11111111의 값으로 캐스팅 되기 때문에 배열의 초기화랑 잘 맞아떨어져서 되는 겁니다.

        ```
        Decimal: 1
         Binary: 00000000 00000000 00000000 00000001
            Hex: 00 00 00 01

        Decimal: -1
         Binary: 11111111 11111111 11111111 11111111
            Hex: FF FF FF FF

        Decimal: -2
         Binary: 11111111 11111111 11111111 11111110
            Hex: FF FF FF FE
        ```

    /* 16진수 표시할 때 0x로 시작한다. 예를 들어 0x31 == 16진수로 31을 의미 */

    /*진수에서 맨 첫 비트는 1마이너스, 0플러스를 의미? */

    /*char형은 상관없음 unsigned char로 캐스팅하기 때문*/

    ### 실습

    ![mem-%20(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A9%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)%20_%20string%20h%204d37401f828243338ad0847d178e4c23/Untitled.png](mem-%20(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A9%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)%20_%20string%20h%204d37401f828243338ad0847d178e4c23/Untitled.png)

    - code

        int main() {
        #include <string.h>
        char arr[]= "hello";
        void *ptr;
        ptr = arr;
        memset(ptr,0,2);
        return 0;
        }

    ### 참고

    [https://modoocode.com/104](https://modoocode.com/104)

    [https://twpower.github.io/79-usage-of-memset-function](https://twpower.github.io/79-usage-of-memset-function)

    [https://codingdog.tistory.com/entry/c언어-memset-어떠한-수들만-초기화-가능할까](https://codingdog.tistory.com/entry/c%EC%96%B8%EC%96%B4-memset-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%88%98%EB%93%A4%EB%A7%8C-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B0%80%EB%8A%A5%ED%95%A0%EA%B9%8C)

    ### 과정

    -void 포인터라서 접근이 안된다. 그래서 이걸 다른 자료형으로 캐스팅해서 바꿔야 함. 

    -value도 캐스팅

    (둘 다 unsigned char *)

    ### 코드 구현

    ```c
    void *ft_memset(void *ptr, int value, size_t num)
    {
    	size_t i;
    	i = 0;
    	while (i < num)
    	{
    		unsigned char *tempptr;
    		tempptr = (unsigned char *) ptr;
    		tempptr[i] = (unsigned char)value;
    		i++;
    	}
    }
    ```

    ### 테스트_메인코드

    ```c
    int main (void)
    {
    	char arr[]= "hello";
    	void *ptr;
    	ptr = arr;
    	//memset(ptr,0,2);
    	ft_memset(ptr, 0, 2);
    	return 0;
    }
    ```

- **ft_bzero**

    memset이랑 비슷한데, 값을 0으로 채우는 것

    ### 형식

    ```c
    #include <strings.h>

    void bzero(void *ptr, size_t num);
    ```

    ### 리턴값

    없음

    ### 코드

    ```c
    void ft_bzero(void *ptr, size_t num)
    {
    	size_t	i;
    	unsigned char	*tempptr;

    	i = 0;
    	while (i < num)
    	{
    		tempptr = (unsigned char *)ptr;
    		tempptr[i] = 0;
    		i++;
    	}
    }
    ```

- **ft_memcpy**

    메모리의 일부분을 복사한다.

    [memcpy](https://modoocode.com/77) 함수의 인자인 `source` 가 가리키는 곳 부터 `num` 바이트 만큼을 `destination` 이 가리키는 곳에 복사한다.

    이 때, `destination` 과 `source` 의 타입은 모두 위 함수와 무관하다. 왜냐하면 이 함수는 단순히 이진 데이터를 복사하는 것이기 때문이다. 또한, 이 함수는 `source` 의 **널 종료 문자(null terminating character)** 을 검사하지 않는다. 언제나 정확히 `num` 바이트 만큼을 복사한다.

    오버플로우 문제를 방지하기 위해 `**destination` 과 `source` 가 가리키는 배열의 크기는 반드시 `num` 바이트 이상이여야 하며, 서로 겹치면 안된다**. (만일 두 메모리 블록이 겹쳐져 있다면 [memmove](https://modoocode.com/78) 함수를 이용하는 것이 현명하다)

    ### 형식

    ```c
    #include <string.h>

    void *memcpy(void *dest, const void *src, size_t n);
    ```

    ### 인자

    `destination`

    데이터가 복사될 곳의 주소로, `void*` 형으로 형 변환 되어서 전달된다.

    `source`

    복사할 데이터들이 위치한 주소로 역시 `void*` 형으로 형 변환 되어서 전달된다.

    `num`

    복사할 데이터의 바이트 수 이다.

    ### 리턴값

    - 성공 시 `dest 의 포인터` 반환
    - 실패 시 `NULL`

    ### 과정/주의

    - ~~src가 n보다 작으면 n만큼 /0이 채워진다.~~
    - src의 0을 검사하지 않음.
    - `src`가
    - src 길이 + 1 로 복사하지 않으면 /0이 안들어감 (dest가 만약 더 길다면 그 뒤에값 남아있음)
    - `src`가 NULL이면 return `dest`

    /* **0 == '/0'** */

    ### 참고

    [https://modoocode.com/77](https://modoocode.com/77)

    ### 코드

    ```c
    #include "libft.h"

    void*ft_memcpy(void *dest, const void *src, size_t n)
    {
    	unsigned char	*tempdest;
    	unsigned char	*tempsrc;
    	size_t			i;

    	if (dest == NULL && src == NULL)
    		return (NULL);
    	i = 0;
    	tempdest = (unsigned char*)dest;
    	tempsrc = (unsigned char*)src;
    	while (i < n) //여기에 && *src 조건 달았더니 틀렸음.
    	{
    		tempdest[i] = tempsrc[i];
    		i++;
    	}
    	return (dest);
    }
    ```

    ### 테스트_메인코드

    ```c
    #include <stddef.h>
    #include <string.h>
    int main() 
    {
      char arr[] = "hahahaha";
      void *dest;
      void *src = "HAHA";
      
      dest = arr;
      printf("%s\n", memcpy(dest, src, 6));
      printf("%s\n", ft_memcpy(dest, src, 6));
      
      return 0;
    }
    ```

- **ft_memccpy**

    src에서 dest로 메모리값을 n만큼 복사. 복사하면서 c를 찾으면 복사를 멈춘다. 

    ### **형식**

    ```c
    #include <string.h> 

    void *memccpy(void *dest, const void *src, int c, size_t n);
    ```

    ### **인자**

    `dest` 복제가 될 곳

    `src` 복제할 원본 데이터

    `c` src에서 만나면 복제를 중단할 데이터 (unsigned char 값)

    `n` 복제할 데이터의 byte 수

    ### **리턴값**

    - 만약 c를 찾으면 dest에 복제가 끝난 데이터의 다음 주소값 (`c 다음 주소값`) - 추가 복제를 쉽게 하기 위하여 다음번지를 return함
    - src에서 c문자를 만나지 못하면 `NULL`

    ### **함수구현**

    ```c
    #include "libft.h"

    void*ft_memccpy(void *dest, const void *src, int c, size_t n)
    {
    	unsigned char	*tempdest;
    	unsigned char	*tempsrc;
    	unsigned char	temp_c;
    	size_t			i;

    	i = 0;
    	temp_c = (unsigned char)c;
    	tempdest = (unsigned char*)dest;
    	tempsrc = (unsigned char*)src;
    	while (i < n)
    	{
    		if (tempsrc[i] == (unsigned char)c)
    		{
    			tempdest[i] = tempsrc[i];
    			return (&tempdest[i + 1]);
    		}
    		tempdest[i] = tempsrc[i];
    		i++;
    	}
    	return (0);
    }
    ```

    ### 테스트코드

    ```c
    #include <string.h>
    int main(void)
    {	
    		char a[] = "abcrqedfdfe";
        char b[] = "abcrqedfdfe";
        char c[] = "cccaaaaaaa";
        memccpy(a, c, 'd', sizeof(char) * 4);
        ft_memccpy(b, c, 'd', sizeof(char) * 4);
        printf("%s\n", a);
        printf("%s\n", b);
    }
    ```

- **ft_memmove**

    ### **형식**

    ```c
    #include <string.h>

    void *memmove(void *dst, const void *src, size_t n);
    ```

    `dst`에 `src`를 `n` 바이트만큼 복사 

    !! src 배열은 src와 dst의 메모리 영역과 겹치지 않는 메모리 영역부터 먼저 복사한다.

    ### 과정

    - memcpy와의 차이 : memcpy는 메모리의 내용을 직접 복사, memmove는 복사할 메모리의 내용을 임시공간에 저장한 후 복사한다. 따라서 memcpy의 속도가 더 빠르지만, memmove가 더 안전하게 동작한다.
    - 예를들어 dst 자신을 한 칸 뒤로 땡겨서 복사한다 쳤을 때, memcpy는 적용을 못하지만 memcpy는 적용이 된다. (원본을 건들이지 않고 하기 때문)
    ~~이제 memcpy도 개선돼서 비슷하다고 함~~
    - void * 이기 때문에 어떤 자료형이든간에 넣을 수 있다. (메모리 잘 생각할것)

    ### 주의

    - 주소가 작을 때 클 때 구분해야 한다.  ( src가 앞에있는 경우 뒤에 dst가 바뀐 뒤에 그 값을 복사하게 될 수가 있기 때문에) 만약 src가 dst보다 주소가 앞에 있는 경우는 src의 맨 뒤부터 복사해줘야 한다. (if src < dst, 뒤부터)
    - 예외처리 : (if dst == src, return dst), n이 0일 때 처리. (return dst)

    ### 리턴값

    - 성공 시 복사된 후의 `dst` 포인터
    - 실패 시 `NULL`

    ### **함수 구현**

    ```c
    #include "libft.h"

    void	*ft_memmove(void *dst, const void *src, size_t n)
    {
    	size_t	i;
    	unsigned char	*tempdst;
    	const unsigned char	*tempsrc;

    	tempdst = (unsigned char*)dst;
    	tempsrc = (unsigned char*)src;
    	i = 0;
    	if (dst == src || n == 0)
    		return (dst);
    	if (dst < src)
    	{
    		while (i < n)
    		{
    			tempdst[i] = tempsrc[i];
    			i++;
    		}
    	}
    	else
    	{
    		while (0 < n--)
    			tempdst[n] = tempsrc[n];
    	}
    	return (dst);
    }
    ```

    ### 테스트_메인코드

    ```c
    #include <stdio.h>
    #include <string.h>
     
    int main()
    {
        char str1[] = "Geeks"; // Array of size 100
        char str2[] = "Quiz"; // Array of size 5
     
        puts("str1 before memmove ");
        puts(str1);
     
        /* Copies contents of str2 to sr1 */
        memmove(str1, str2, sizeof(str2));
     
        puts("\nstr1 after memmove ");
        puts(str1);
     
        return 0;
    }
    ```

    ```c
    #include <stdio.h>
    #include <string.h>

    int main() 
    {
      char arr[] = "hahaHAHA";
      void *dest;
      void *src;
      
      src = &arr[4];
      dest = arr;
      ft_memmove(dest, src, 3);
      return 0;
    }
    ```

- **ft_memchr**

    메모리 블록에서의 문자 (chr)을 찾는다.

    ### **형식**

    ```c
    #include <string.h>

    void *memchr(const void *str, int c, size_t n);
    ```

    `str` 에서 `n`바이트까지 중 `c`를 찾는다. 

    ### 주의

    - 찾을 문자 `c`가  int형으로 주어지나, 내부적으로는 한 바이트씩 비교하기 대문에 `unsigned char`로 변환되어 사용된다.
    - 찾을 문자 `'\0'`들어갔을 때도 찾아야하니까 조건 `while (str)`이런거 쓰면 안됨.
    - `return ((void*)&str[i]);` void 포인터는 지정된 형이 없기대문에 인덱스로 (배열로) 접근이 안됨.  —> `return ((void *)str + i);`

    ### 리턴값

    - `c`를 찾을 경우 : `c`가 있는 주소 (포인터)
    - 찾지 못한 경우 : `NULL`

    ### **함수 구현**

    ```c
    #include "libft.h"

    void	*ft_memchr(const void *str, int c, size_t n)
    {
    	size_t			i;
    	unsigned char	*tempstr;
    	unsigned char	tofind;

    	tempstr = (unsigned char*)str;
    	tofind = (unsigned char)c;
    	i = 0;
    	while (i < n)
    	{
    		if (tempstr[i] == tofind)
    			return ((void*)&str[i]);
    		i++;
    	}
    	return (0);
    ```

- **ft_memcmp**

    ### **형식**

    ```c
    #include <string.h>

    int memcmp(const void *str1, const void *str2, size_t n);
    ```

    `n`바이트만큼 `str1`과 `str2`를 비교한다. (각 바이트를 `unsigned char`로 비교함)

    ### 주의

    - 바이트 단위로 비교하기 때문에 모두 unsigned char*로 캐스팅해줘야 한다.
    - 리턴값 `str1[i] - str2[i]` 하면 됨

    ### 리턴값

    - `str1` `str2` 같을 때 : `0`
    - 다를 때 그 다른 지점에서 `str1` 의 값이 더 크면 `<0`  , `str2`의 값이 더 크면 `>0`

    ### **함수 구현**

    ```c
    #include "libft.h"

    int ft_memcmp(const void *str1, const void *str2, size_t n)
    {
    	unsigned char	*s1;
    	unsigned char	*s2;
    	size_t			i;

    	s1 = (unsigned char*)str1;
    	s2 = (unsigned char*)str2;
    	i = 0;
    	while (i < n)
    	{
    		if (s1[i] != s2[i])
    			return (s1[i] - s2[i]);
    		i++;
    	}
    	return (0);
    }
    ```