---
layout: post
title: "[CPP] 04. 클래스 완성"
date: 2021-12-08 23:59:00 +0900
category: CPP
---
# 04-1. 정보은닉 (Information Hiding)

- 멤버 변수를 private로 선언하고 해당 변수에 접근하는 함수를 별도로 정의하여 안전한 형태로 멤버 변수의 접근을 유도하는 것. 좋은 클래스의 기본 조건이다.

### 엑서스 함수 (access function)

- 이 때 멤버변수에 접근하는 함수를 **엑서스 함수 (access function)**이라고 한다.
    - *java의 getter setter*

### const 함수

```cpp
int getX() const;
int getY() const;
void ShowInfo() const;
```

- const 함수는 해당 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다는 선언이다.
    - const로 선언된 함수에서 멤버변수의 값을 변경하면 컴파일 에러가 발생한다.
- const 함수 내에서는 const가 아닌 함수의 호출이 불가하다.
- const 참조자를 대상으로 값의 변경 능력을 가진 함수(non-const)의 호출을 허용하지 않는다.
- 즉, const 참조자를 이용해서는 const 함수만 호출이 가능하다.
- const 사용으로 안정성을 높일 수 있다.

# 04-2. 캡슐화 (Encapsulation)

- 알약 캡슐 예시
- 기능을 하나로, 순서를 정하여 묶는것.
- 캡슐화의 범위를 결정하는 것이 쉽지 않다. 정답이 없기때문에
- 캡슐화를 할 땐 이왕이면 멤버 변수를 은닉해서 캡슐화하는 것이 안전하다. 하지만 정보은닉과 캡슐화는 다른 개념이라는 것을 숙지하자.

# 04-3 생성자(Constructor)와 소멸자(Destructor)

## 생성자

- 생성자를 통해 객체 생성과 동시에 초기화할 수 있다.
- 클래스의 이름과 함수 이름이 동일하며, 반환형이 없다.
- 객체 생성 시 딱 한 번 호출된다.
- 생성자도 함수의 일종이기 때문에
    - 오버로딩이 가능하다.
    - 매개변수에 '디폴트값'을 설정할 수 있다.
- 매개변수가 없는 생성자의 경우 소괄호를 쓰지 않아야 한다. (함수 원형 선언과 겹칠 수 있기 때문)
    
    ```cpp
    class MyClass
    {
    	MyClass()
    	{
    		...
    	}
    }
    
    int main(void)
    {
    	MyClass mc(); // (X)
    	MyClass mc;   // (O)
    
    	MyClass mc(); // 반환형이 MyClass인 함수 원형 선언
    }
    ```
    

## 멤버 이니셜라이저 (Member Initializer)

### 멤버 이니셜라이저 (Member Initializer)를 이용한 멤버 초기화

```cpp
class Rectangle
{
private:
	Point upLeft;
	Point lowRight;
public:
	Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
	void ShowRecInfo();
}

Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
						:upleft(x1, y1), lowRight(x2, y2) // <- 멤버 이니셜라이저
{
		// empty
}
```

- 밑의 생성자 정의 부분의 : 이후가 멤버 이니셜라이저.
    - 객체 upLeft의 생성과정에서 x1과 y1을 인자로 전달받는 생성자를 호출하라 (Point)
    - 객체 lowRight의 생성과정에서 x2와 y2를 인자로 전달받는 생성자를 호출하라 (Point)
- 정리하자면, 멤버 이니셜라이저는 멤버변수로 선언된 객체의 생성자 호출에 활용된다.

### 멤버 이니셜라이저 (Member Initializer)를 이용한 변수 및 const 상수(변수) 초기화

- 멤버 이니셜라이저는 객체가 아닌 멤버의 초기화에도 사용할 수 있다.
    
    ```cpp
    class SoSimple
    {
    private:
        int num1;
        int num2;
    public:
        SoSimple(int n1, int n2) : num(n1) // 멤버 변수 초기화
        {
            num2 = n2;
        }
    };
    ```
    
- 즉, 생성자의 몸체에서 초기화하는 방법과 이니셜라이저를 이용하는 방법 중에서 선택이 가능하다.
- 일반적으로는 이니셜라이저를 선호한다.
    - 초기화의 대상을 명확히 인식할 수 있기 때문
    - 성능에서 조금 더 이점이 있기 때문
- 이니셜라이저를 통해서 초기화되는 멤버는 선언과 동시에 초기화가 이뤄지는 것과 같은 유형의 바이너리 코드를 구성한다.
- 따라서 const 변수도 이니셜라이저를 이용하여 초기화가 가능하다!
    - const 변수는 생성과 동시에 초기화해야 하기 때문
- (몸체에서 초기화할 경우 선언 후 따로 초기화하는 형태의 바이너리 코드)

### 이니셜라이저를 이용하여 멤버변수로 참조자 선언하기

- const  변수와 마찬가지로 '참조자'도 선언과 동시에 초기화해야 한다.
- 따라서 이니셜라이저를 이용하면 참조자도 멤버 변수로 선언될 수 있다.

## 디폴트 생성자 Default Constructor

- 메모리 공간의 할당 이후 생성자의 호출까지 완료되어야 '객체'라고 할 수 있다. 즉, **객체가 생성되려면 반드시 생성자가 호출되어야 한다.**
- 클래스에서 생성자를 따로 정의하지 않으면, 디폴트 생성자가 자동으로 삽입되어 호출된다. (자세한 내용은 추후)
    - 디폴트 생성자는 인자를 받지 않고, 내부적으로도 아무 일도 하지 않는 생성자이다.
- new로 동적할당하여 생성할 시에도 생성자가 호출된다.

### 생성자 불일치

- 디폴트 생성자는 생성자가 하나도 정의되어있지 않을 때에만 삽입된다. 따라서 매개변수가 있는 생성자를 선언한 경우, 기본 생성자는 존재하지 않는 상태이다.

## private 생성자

- 클래스 내부에서만 객체 생성을 허용하려는 목적으로, private 생성자를 선언한다.

## 소멸자

- 객체 소멸 시 반드시 호출되는 것이 소멸자이다.
- 형태는 클래스의 이름 앞에 `~`가 붙는 형태이다.
    
    ```cpp
    ~AAA(){...}
    ```
    
- 반환형이 없으며, 매개변수는 void형으로 선언되어 있어야 하기 때문에 오버로딩도, 디폴트값 설정도 불가능하다.
- 소멸자는 객체 소멸 과정에서 자동으로 호출이 된다.
- 소멸자를 따로 정의해주지 않으면 디폴트 생성자와 마찬가지로, 아무 일도 하지 않는 **디폴트 소멸자**가 자동으로 삽입된다.
- 생성자에서 할당한 리소스의 소멸에 사용된다. (생성자 내에서 `new` 연산자를 이용하여 할당해놓은 메모리 공간이 있다면, 소멸자에서 `delete`연산자를 이용하여 메모리공간을 소멸한다.)
- 소멸자를 통해서 객체 소멸 과정에서 처리해야 할 일들을 자동으로 처리할 수 있다.
- 예시
    
    ```cpp
    class Person
    {
    private:
    	char	*name;
    	int		age;
    public:
    	Person(char *myname, int myage)
    	{
    		int len=strlen(myname)+1;
    		name = new char[len]; // 메모리 할당
    		strcpy(name, myname);
    		age = myage;
    	}
    	~Person() // 소멸자!
    	{
    		delete []name;
    	}
    };
    ```
    

# 04-4. 클래스와 배열, this 포인터

- 객체배열 및 객체 포인터 배열 - C에서의 구조체 포인터 배열과 유사하다.

## 객체 배열

```cpp
MyClass myclass[10]; //객채 배열 선언
MyClass *ptrArr=new MyClass[10]; //객체배열 동적으로 할당할 경우
```

- 객체 배열의 선언 과정에서는 호출할 생성자를 별도로 명시하지 못한다. (생성자 인자 전달 못하니)
- 따라서 기본 형태의 생성자가 반드시 정의되어있어야 한다. 다른 초기화를 원할 경우, 배열 선언 이후 별도로 초기화를 해줘야 한다.
- 마찬가지로 배열 소멸 시에도 그 배열을 구성하는 객체의 소멸자가 호출된다.

## 객체 포인터 배열

- 객체의 주소값 저장이 가능한 포인터로 이뤄진 배열
- 보통 포인터 배열에 바로 객체 생성해서 넣어주기 때문에, 종료 시 delete ptrArr[i]로 모두 해제해주어야 한다.

## this 포인터

- 멤버함수 내에서 this라는 이름의 포인터를 사용한다.
- 이는 객체 자신의 주소값을 가리키는 용도로 사용되는 포인터이다. (객체 자신을 가리키는 포인터)
- 객체 자신의 멤버를 호출할 때 `this->var(멤버변수 이름)`식으로 표현하여 호출할 수 있다.

## Self-Reference의 반환

- Self-Reference란 객체 자신을 참조할 수 있는 참조자를 의미한다.
- 이를 활용하여 자신의 참조에 사용할 수 있는 참조자를 반환하는 함수를 구성할 수 있다.
    
    ```cpp
    class MyClass 
    {
    private:
    	int num=0;
    public:
    	MyClass& func()
    	{
    		return *this;
    	}
    }
    ```