---
layout: post
title: "[C공부] 04_데이터 표현방식의 이해"
date: 2020-03-07 17:20:23 +0900
category: '[C]'
---

# 4-1. 컴퓨터가 데이터를 표현하는 방식

### 진수

- 컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산도 진행한다.
- `진수`: n진수 - 데이터를 표현하는데 n개의 기호(숫자)를 사용한다는 뜻.

### 데이터의 표현 단위인 `비트(bit)`와 `바이트(byte)`

- `비트`: 컴퓨터가 표현하는 데이터의 최소 단위로서 2진수 값 하나를 저장할 수 있는 메모리의 크기를 뜻힌다. (8개의 비트가 모여 1바이트가 됨)
- `바이트`: 비트를 8개 묶은 단위.

### 8진수와 16진수를 이용한 데이터 표현

```c
int num1 = 10; //특별한 선언이 없으면 10진수의 표현
int num2 = 0xA; // 0x로 시작하면 16진수로 인식
int num3 = 012; // 0으로 시작하면 8진수로 인식

num1 == num2 == num3 == 10
```

# 4-2. 정수와 실수의 표현방식

### **정수의 표현 방식**

- 정수의 가장 왼쪽에 존재하는 비트는 '**부호비트**'! (양수는 `0`, 음수는 `1`)
이 비트를 `MSB`(Most Significant Bit)라고 한다.  MSB를 제외한 나머지 비트들은 데이터의 크기를 나타낸다.
- 음의 정수를 표현할 때에는 **2의 보수법**!

```c
1. 양의 정수에 보수를 취한다 (1은 0으로, 0은 1로)
2. +1을 한다 (올림수 1은 버려져서 0)

 00000101 (정수 +5)
 11111010 (보수를 취함)
+00000001 (+1을 한다)
=11111011 (정수 -5)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
  00000101 (정수+5)
 +11111011 (정수-5)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
=100000000 (맨 왼쪽 올림수 1은 버려져서 0이 됨)

//음의 정수 보고 값 알아낼 때도 2의 보수법으로 계산하면 됨
//2의 보수법은 곧 *-1 과 같다. 
```

### **실수의 표현방식**

- 컴퓨터가 실수를 표현하는 기본방식 '**부동 소수점 방식'**

![https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F133D23574D9170A53BB1C3](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F133D23574D9170A53BB1C3)

- 실수 표현의 오차, '**부동 소수점 오차'** 존재
ex - 0.0 표현할 경우 2의 n승은 0이 될 수 없기 때문에
- (결론) 컴퓨터는 실수를 100% 정확히 표현하지 못한다. 다만 근사치를 표현할 뿐이다.

# 4-3. 비트 연산자

![https://lh3.googleusercontent.com/proxy/-WY3NbdDqDIO2ctpeOIDjYIku20bGppfCP6qZzBkrK3Th3DhVnGlLhNgFG3IPtXfBmBwAMqTJRxAbeJDWIdphQ5D2cs8qVtsyPVYjCxEYod9BOqueiRdwFwGDjmjv-FCD-kI-e5nhv3vo9rw13ON7XhFHOqA3A](https://lh3.googleusercontent.com/proxy/-WY3NbdDqDIO2ctpeOIDjYIku20bGppfCP6qZzBkrK3Th3DhVnGlLhNgFG3IPtXfBmBwAMqTJRxAbeJDWIdphQ5D2cs8qVtsyPVYjCxEYod9BOqueiRdwFwGDjmjv-FCD-kI-e5nhv3vo9rw13ON7XhFHOqA3A)

- `&` : (AND) 둘 모두 1일때 1 반환
- `|` : (OR) 둘 중 하나라도 1일 때 1 반환
- `^` : (XOR) 두 비트가 다른 경우에 1 반환
- `~` : (NOT) 0에서 1로, 1에서 0로 반전 (==보수연산) 
*MSB도 반전되어 부호마저 바뀜*
- `<< n` : (왼쪽이동Shift) 비트 열을 왼쪽으로 `n`칸씩 이동, 이동하여 생긴 오른쪽 빈칸은 0으로 채워지고, 밀려나는 왼쪽 빈칸은 버려진다.
    - 비트 열을 왼쪽으로 한칸씩 이동시킬 때마다 정수의 값은 두배가 된다!
    - 반대로, 오른쪽으로 한칸씩 이동시킬 때마다 정수의 값은 2로 나누어진다!
- 비트연산은 곱셈이나 나눗셈보다 CPU 입장에서 가벼운 연산이기때문에 성능 향상으로 이어진다.
- `>> n` : (오른쪽이동Shift) 비트 열을 오른쪽으로 `n`칸씩 이동, 밀려나는 비트 소멸 
-MSB `0`일 경우(양수)-새로 생긴 왼쪽 빈칸은 0으로 채워짐
-MSB `1`일 경우(음수)-CPU에 따라서 값이 달라진다. `1`을 채우거나, `0`을 채우거나.